/*
https://www.geeksforgeeks.org/given-a-string-print-all-possible-palindromic-partition/

The idea is to go through every substring starting from first character, check if it is palindrome. If yes, then add the substring to solution and recur for remaining part. Below is complete algorithm.

Below is the implementation of above idea.
*/

// Java program to pring all palindromic 
// partitions of a given string

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;

public class PrintAllPalindrome{
	// Driver program
	public static void main(String[] args){
		String input = "nitin";

		allPalPartions(input);

	}

	// Function to print all possible palindormic partitions of str.
	// It mainly creates verctors and call allPalParUtil()
	private static void allPalPartions(String input){
		int n = input.length();

		// To store all palindromic partiions
		ArrayList<ArrayList<String>> allPart = new ArrayList<>();

		// To store current palindromic partition 
		Deque<String> currPart = new LinkedList<String>();

		// Call recursive funciton to generate all partions 
		// store in allPart
		allPalPartionsUtil(allPart, currPart, 0, n, input);

		//print all partions generated by above call
		for (int i=0; i<allPart.size(); i++){
			for (int j=0; j < allPart.get(i).size(); j++){
				System.out.print(allPart.get(i).get(j) + " ");
			}
			System.out.println();
		}
	}

	// Recursive function to find all palindromic
	// partitions of input[start .. n-1] 
	// allPart --> A ArrayList of Deque of strings. 
	// Every Deque inside it stores a partions
	// currPart --> A Deque of string to store current partions. 
	private static void allPalPartionsUtil(
		ArrayList<ArrayList<String>> allPart,
		Deque<String> currPart, 
		int start, int n, 
		String input){

		// If start has reached len
		if (start >=n ){
			allPart.add(new ArrayList<>(currPart));
			return;
		}

		// Pick all possible ending points for substrings
		for (int i = start; i < n; i++){
			// If substring str[start...i] is palidrome
			if (isPalindrome(input, start, i))
			{
				// All the substring to the result 
				currPart.addLast(input.substring(start, i+1));

				// Recur for remaining substring 
				allPalPartionsUtil(allPart, currPart, i+1, n, input);

				// Remove substring str[start...i] from current partion
				currPart.removeLast();
			}
		}
	}

	// A tulity function to check
	// if a input is Palidorme
	private static boolean isPalindrome(String input, 
		int start, 
		int i){
		while(start < i){
			if(input.charAt(start++) != input.charAt(i--))
				return false;
		}
		return true;
	}
}
